package tron;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.Scanner;


/**
 * This class is a starter file for a "Tron LightCycle" game in which two players drive lightcycles in
 * an arena, leaving trails behind them as they go.  If a player bumps into one of these trails or
 * into a wall, the other player wins.  This game does not try to show the lightcycles themselves,
 * only the trails that are left.  In this starter program, there is just one lightcycle that leaves a
 * trail of random colors, and crossing a trail or hitting a wall has no effect.
 */
public class TronPanel extends JPanel implements FocusListener, KeyListener, ActionListener, MouseListener {

	private Board arena;  // The arena in which the "lightcycles" move.  It consists of squares arranged
	                            // into rows and columns.
	
	private JLabel message;   // This label appears under the arena and holds a message for the user.
	private JPanel titlePanel;
	private JPanel bottom;
	private JPanel highScorePanel;
	private Timer timer;  // Whenever the arena has the input focus, this timer emits a stream of ActionEvents
	                      // that drive the action.  Everytime an ActionEvent occurs, the actionPerformed method
	                      // in this class is called.
	private JLabel title;
	private JLabel highScoreTable;
	
	private final static int ROWS = 60;         // Number of rows in the arena.
	private final static int COLUMNS = 70;      // Number of columns in the arena.
	private final static int BLOCKSIZE = 10;    // Size of each square in the arena-- used only in creating the arena object.
	private final static int BORDER_WIDTH = 5;  // The width of the colored border around the arena.
	
	private final static int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3, NOT_MOVING = 4; // Constants representing possible directions.
	private int direction_1;// The direction that the "lightcycle" is currently heading, one of the above constants.
	private int direction_2;
	
	
	private int currentColumn_1, currentRow_1;// The current row number and column number where the "lightcycle" is located.
	private int currentColumn_2, currentRow_2;
	
	private boolean  blueLost, redLost;
	private Color color;
	
	

	
	/**
	 * The "constructor" for the TronPanel class creates all the components that are
	 * displayed in the panel and adds them to the panel.  It also sets up listening
	 * for events.  The panel listens for mouse events from the label and from the
	 * arena, for focus events from the arena, for action events from the timer, and
	 * for key events from the arena.  (Thus, key events are only processed when the
	 * arena has the input focus.)
	 */
	public TronPanel() {
		highScorePanel = new JPanel();
		highScorePanel.setBackground(Color.BLACK);
		highScorePanel.setPreferredSize(new Dimension(BLOCKSIZE*COLUMNS + 2*BORDER_WIDTH, BLOCKSIZE*ROWS + 2*BORDER_WIDTH));
		highScoreTable = new JLabel(text, JLabel.CENTER);
		
		
		
		
		
		titlePanel = new JPanel();
		titlePanel.setBackground(Color.BLACK);
		titlePanel.setPreferredSize(new Dimension(BLOCKSIZE*COLUMNS + 2*BORDER_WIDTH, BLOCKSIZE*ROWS + 2*BORDER_WIDTH));
		title = new JLabel();
		title.setIcon(new ImageIcon(getClass().getResource("/images/Slide1.png")));
		validate();
		title.setBackground(Color.BLACK);
		title.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
		arena = new Board(ROWS, COLUMNS, BLOCKSIZE, BLOCKSIZE, Color.GRAY, BORDER_WIDTH);
		message = new JLabel("To START, Click the Anywhere", JLabel.CENTER);
		message.setBackground(Color.LIGHT_GRAY);
		message.setBorder(BorderFactory.createEmptyBorder(10,0,10,0));
		bottom = new JPanel();
		bottom.setLayout(new BorderLayout());
		bottom.setBackground(Color.LIGHT_GRAY);
		setBackground(Color.DARK_GRAY);
		setLayout(new BorderLayout(3,3));
		bottom.add(message,BorderLayout.CENTER);
		titlePanel.add(title,BorderLayout.CENTER);
		add(bottom, BorderLayout.SOUTH);
		add(titlePanel,BorderLayout.CENTER);
		setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY,3));
		arena.setGroutingColor(null);//if you want to set outline color of each block
		arena.addFocusListener(this);
		arena.addKeyListener(this);
		arena.addMouseListener(this);
		message.addMouseListener(this);
		message.addKeyListener(this);
		titlePanel.addMouseListener(this);
	}

	/**
	 * This method responds to the action events that are generated by the timer as
	 * long as the game is in progress.  It simply moves the "lightcycle" one square
	 * in the currently selected direction.  (It gets "stuck" in the same position
	 * when it hits one of the walls of the arena.)  The square containing the
	 * "lightcycle" is colored with a random color.  Note that if the current
	 * direction is NOT_MOVING, then the light cycle does not move.
	 */
	public void actionPerformed(ActionEvent e) {
		
		switch (direction_1) {
		case UP:
			
				currentRow_1--;// Move up one row, unless already in the top row, number 0.
				redLost = Collision(currentRow_1,currentColumn_1,Color.red);
			break;
		case DOWN:
			
				currentRow_1++;   // Move down one row, unless already in the bottom row, number ROWS-1.
				redLost = Collision(currentRow_1,currentColumn_1,Color.red);
			break;
		case RIGHT:
		
				currentColumn_1++;  // Move right one column, unless already in the rightmost column, number COLUMNS-1.
				redLost = Collision(currentRow_1,currentColumn_1,Color.red);
			break;
		case LEFT:
		
				currentColumn_1--;  // Move left one column, unless already in the leftmost column, number 0.
				redLost = Collision(currentRow_1,currentColumn_1,Color.red);
			break;
		}
		switch (direction_2) {
		case UP:
				currentRow_2--;    // Move up one row, unless already in the top row, number 0.
				blueLost = Collision(currentRow_2,currentColumn_2,Color.blue);
			break;
		case DOWN:
				currentRow_2++;   // Move down one row, unless already in the bottom row, number ROWS-1.
				blueLost = Collision(currentRow_2,currentColumn_2,Color.blue);
			break;
		case RIGHT:
				currentColumn_2++;  // Move right one column, unless already in the rightmost column, number COLUMNS-1.
				blueLost = Collision(currentRow_2,currentColumn_2,Color.blue);
			break;
		case LEFT:
				currentColumn_2--;  // Move left one column, unless already in the leftmost column, number 0.
				blueLost = Collision(currentRow_2,currentColumn_2,Color.blue);
			break;
		}
		
		blueWins(redLost);
		redWins(blueLost);
		
	}
	
	/**
	 * Checks if the sQaure designated by row,col is black and if it is within the bounds of the board. If all is OKAY paint that square, if not stop game
	 * @param row
	 * @param col
	 * @param c
	 */
	public boolean Collision(int row, int col, Color c){
		if(arena.getRed(row, col)==0 && arena.getGreen(row, col)==0 && arena.getBlue(row, col)==0) 
		{
				if(row < ROWS && row >= 0 && col >= 0 && col < COLUMNS) 
				{
					arena.setColor(row, col, c);
					return false;
				}
				else {
					timer.stop();
					return true;
				}
		}
		else {
			timer.stop();
			return true;
		}
	}
	
	public void blueWins(boolean redLost){
		if(redLost){
			message.setText("Blue Wins! Press SPACEBAR to continue");
			message.setOpaque(true);
			message.setBackground(Color.BLUE);
			arena.setBorder(BorderFactory.createLineBorder(Color.BLUE, BORDER_WIDTH));
		}
	}
	
	public void redWins(boolean blueLost){
		if(blueLost){
			message.setText("Red Wins! Press SPACEBAR to continue");
			message.setOpaque(true);
			message.setBackground(Color.RED);
			arena.setBorder(BorderFactory.createLineBorder(Color.RED, BORDER_WIDTH));
		}
	}

	/**
	 * This method is called when the user presses a key on the keyboard (but only if the
	 * arena has the input focus).  If the user presses an arrow key, the current direction
	 * of motion of the light cycle is set to the direction that corresponds to the arrow
	 * (up, down, left, or right).  If the "P" key is pressed, the game is paused (by giving
	 * the input focus to the message component, which indirectly stops the game from running).
s	 */
	public void keyPressed(KeyEvent e) {
		int code = e.getKeyCode();
		// This code tells which key was pressed.  The value is one of the 
		                            // virtual keyboard ("VK") constants in the KeyEvent class.
		if (code == KeyEvent.VK_LEFT)
			direction_1 = LEFT;
		else if (code == KeyEvent.VK_RIGHT)
			direction_1 = RIGHT;
		else if (code == KeyEvent.VK_UP)
			direction_1 = UP;			
		else if (code == KeyEvent.VK_DOWN)
			direction_1 = DOWN;
		
		
		if(code ==KeyEvent.VK_A)
			direction_2=LEFT;
		else if (code == KeyEvent.VK_D)
			direction_2 = RIGHT;
		else if(code == KeyEvent.VK_W)
			direction_2 = UP;
		else if (code == KeyEvent.VK_S)
			direction_2 = DOWN;
		
		if (code == KeyEvent.VK_ENTER)
			arena.requestFocus();
		if(code == KeyEvent.VK_SPACE)
			message.requestFocus();
		if(code == KeyEvent.VK_ESCAPE){
			System.exit(0);
		}
		
	}

	/**
	 * This method is called when the arena gains focus, which means that it will start
	 * receiving Key events.  When this happens, the game action is turned on (by creating
	 * a timer to drive the game), the color of the arena's border is changed to cyan,
	 * and the text of the message is changed.
	 */
	public void focusGained(FocusEvent e) {
		arena.setBorder(BorderFactory.createLineBorder(Color.GREEN, BORDER_WIDTH));
		arena.fill(null);  // This resets all the squares to black to erase the picture from the previous run.
		currentColumn_1 = COLUMNS/4*3;// Starting column, 3/4 of the way across the scree.
		currentColumn_2 = COLUMNS/4;
		currentRow_1 = ROWS/2;// Starting row, halfway down the screen
		currentRow_2 = ROWS/2;
		blueLost = false;
		redLost=false;
		arena.setColor(currentRow_1, currentColumn_1,Color.red);  // color first square red
		arena.setColor(currentRow_2, currentColumn_2, Color.blue);
		direction_1 = NOT_MOVING;
		direction_2 = NOT_MOVING;
		message.setBackground(Color.LIGHT_GRAY);
		message.setText("GO			Spacebar to Pause");
		timer = new Timer(50,this); // timer generates an ActionEvent every 50 milliseconds
		timer.start();
	}

	/**
	 * This method is called when the arena loses focus, which means that it will not
	 * receive Key events.  When this happens, the game is suspended (by turning off 
	 * the timer that drives the game), the color of the arena's border is changed to
	 * gray, and the text of the message is changed.
	 */
	public void focusLost(FocusEvent e) {
		arena.setBorder(BorderFactory.createLineBorder(Color.GRAY, BORDER_WIDTH));
		if (timer != null)
			timer.stop();
		timer = null;
		message.setBackground(Color.LIGHT_GRAY);
		message.setText("To START, Hit Enter");
	}

	/**
	 * Mouse clicks on the arena and on the message are simply used to move the focus to
	 * the component that was clicked.  (The point of giving the focus to the message is
	 * simply to make the arena lose focus, which causes the game to be paused.)
	 */
	public void mousePressed(MouseEvent e) {
		if (e.getSource() == message || e.getSource() == titlePanel){
			add(arena);
			arena.requestFocus();
			remove(titlePanel);}
		else
			message.requestFocus();
	}

	
	// The following subroutines are required by the "KeyListener" and "MouseListener" interfaces,
	// but are not used in this program.  They are defined as subrotines with empty bodies, which
	// means that they do nothing.
	
	public void mouseClicked(MouseEvent e) {}
	public void mouseEntered(MouseEvent e) {}
	public void mouseExited(MouseEvent e) {}
	public void mouseReleased(MouseEvent e) {}
	public void keyReleased(KeyEvent e) {}
	public void keyTyped(KeyEvent e) {}

	public static String readHighScores() throws Exception{
		FileReader file = new FileReader("/src/highScores/highScoreTable.txt");
		BufferedReader reader = new BufferedReader(file); //reader objects
		
		String text = "";
		String line = reader.readLine();
		while(line != null) //while still information in file print to console
		{
			text+=line;
			line = reader.readLine();
		}
		reader.close();
		return text;
	}
	

	}


 // end class TronPanel
